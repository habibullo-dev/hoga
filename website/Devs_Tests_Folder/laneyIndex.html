<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tasklist widget</title>
    <link rel="stylesheet" href="laneyStyles.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
  <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=xNRson29tvGTxA6Tqp9W5zUYfmS8-h-dsnQCsDFPMKeozJKFGqyEO5nfSpKzoTA83DrE9EqMai9GMfOG9g2UUVEEjwY4Bk0pyHbnRLefHs8icIWotr3laIPJYCttaQ3ihtEuz6czX_uhn36y2ZH-cKhJDKvhljmAL8OAwMkCfgAruRwmCQcab5LYthtL8QftnqHh3yo21HTJGZ_9PMhhVCZ4U9FTBGU11iJZcpeRY0G4G_dR5-SWNdMQQzQhOoC6alTMqRKcu5SELaA45tHc_Q" charset="UTF-8"></script></head>
  <body>
    <div class="tasklist">
      <div class="tabs">
        <button id="showIncompleteButton">Incomplete</button>
        <div class="separator">|</div>
        <button id="showCompletedButton">Completed</button>
      </div>
      <ul id="taskList" class="dragContainer"></ul>
      <ul id="completedList" class="dragContainer"></ul>
      <input
        type="text"
        id="taskInput"
        placeholder="Add new task:"
        class="task-input"
      />
    </div>

    <script>
    
      const taskInput = document.getElementById('taskInput');
      const taskList = document.getElementById('taskList');
      const completedList = document.getElementById('completedList');

      let taskListSetup = [] //local taskListSetup

      if (completedList) {
          taskList.style.display = 'block';
          completedList.style.display = 'none';
      };

      const showCompletedButton = document.getElementById('showCompletedButton');
      const showIncompleteButton = document.getElementById('showIncompleteButton');

      // event listener for adding new list item with enter key
      taskInput.addEventListener('keypress', function(e) {

          if (e.key === 'Enter') {
              const taskText = taskInput.value.trim();

              // create list element
              if (taskText !== '') {
                  const li = document.createElement('li');
                  li.classList.add("draggable")
                  li.setAttribute('draggable', 'true');

                  // create check-off button element
                  const checkedOff = document.createElement('button');
                  checkedOff.innerHTML = '<i class="fa-solid fa-square-check"></i>';
                  checkedOff.classList.add('checked-off');
                  li.appendChild(checkedOff);

                  // add text content as a span
                  const taskSpan = document.createElement('span');
                  taskSpan.textContent = taskText;
                  li.appendChild(taskSpan);

                  // create delete button element
                  const deleteBtn = document.createElement('button');
                  deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                  deleteBtn.classList.add('delete-btn');
                  li.appendChild(deleteBtn);

                  // event listener to remove list item when delete button is clicked
                  deleteBtn.addEventListener('click', function(e) {
                      e.currentTarget.parentNode.remove();
                  });

                  // event listener to move task to completed list when checked off
                  checkedOff.addEventListener('click', function(e) {
                      const taskItem = e.currentTarget.parentNode;
                      taskItem.querySelector('.checked-off').remove();

                      completedList.appendChild(taskItem);
                  })

                  //send data for fetch:
                  taskListSetup.push(taskInput.value) //⚠️Important: later as we add more "features" to this widget, this format needs to be changed by adding more of the individual task customizations.

                  taskList.appendChild(li);
                  taskInput.value = '';

                  
              }

                  draggables = document.querySelectorAll('.draggable') //re-selects all draggable elements
                  draggables.forEach(draggable => {
                  draggable.addEventListener('dragstart', () => { //fired when user starts dragging an element.
                      draggable.classList.add('dragging') //adds a class to indicated the element is being dragged
                  })

                  draggable.addEventListener('dragend', () => { //fired when user stops dragging the element.
                      draggable.classList.remove('dragging') //removes the dragging class
                  })
                  })
              }
          });

          showCompletedButton.addEventListener('click', function() {
              if (completedList) {
                  taskList.style.display = 'none';
                  completedList.style.display = 'block';
              }
          });

          showIncompleteButton.addEventListener('click', function(e) {
              if (completedList) {
                  taskList.style.display = 'block';
                  completedList.style.display = 'none';
              }
          });

          //onLaunch setup
          let draggables = document.querySelectorAll('.draggable') //draggable elements
          const dragContainers = document.querySelectorAll('.dragContainer') //containers that can handle the draggables

          draggables.forEach(draggable => {
          draggable.addEventListener('dragstart', () => { //fired when user starts dragging an element.
              draggable.classList.add('dragging') //adds a class to indicated the element is being dragged
          })

          draggable.addEventListener('dragend', () => { //fired when user stops dragging the element.
              draggable.classList.remove('dragging') //removes the dragging class
          })
          })

          dragContainers.forEach(container => {
          container.addEventListener('dragover', e => { //The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds).
              e.preventDefault()
              const afterElement = getDragAfterElement(container, e.clientY)
              const draggable = document.querySelector('.dragging') //name the item currently being dragged
              if (afterElement == null) {
              container.appendChild(draggable)
              } else {
              container.insertBefore(draggable, afterElement)
              }
              const dataProcessing = setTimeout(()=>{
                clearTimeout
              }, 5000)
          })
          })

          function getDragAfterElement(container, y) {
          const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')]
          //^ selects all moveable elements except the one currently being dragged.
          return draggableElements.reduce((closest, child) => { //closest is acc, child is current value.
              const box = child.getBoundingClientRect() //Retrieves the bounding rectangle of the current child element. Stuff like top, bottom, left, right, width, and height.
              const offset = y - box.top - box.height / 2
              //y = current cursor pos, box.top = current val top value, box.height current val "length"/height by 2 to find its y axis middle.
              if (offset < 0 && offset > closest.offset) { //after all this calc, if offset is "higher" in y than closest, return below obj
              return { offset: offset, element: child }
              } else {
              return closest
              }
          }, { offset: Number.NEGATIVE_INFINITY }).element //initial value of the acc. it will be -infinity to guarantee all other elements are considered as closer and thus, influencable by the reduce.
          }

          //endpoint fetch setups:

          function saveTaskListSetup(){
            fetch("/taskDataGrab", {method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({"task_settings": taskListSetup,})
            
        })
        .then(res=>res.json())
        .then()
          }
    </script>
  </body>
</html>
